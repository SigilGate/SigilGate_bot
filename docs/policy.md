# Политика ролей и статусов

## Статусы пользователей

| Статус | Смысл |
|---|---|
| `inactive` | Новый (ожидает одобрения) ИЛИ заблокированный по любой причине |
| `active` | Активный: полный доступ, может управлять устройствами |
| `archived` | Терминальный: данные сохранены, операции недоступны |

`inactive` служит двум сценариям:
- Только что зарегистрировался — ждёт одобрения администратора (`core_nodes: []`)
- Заблокирован: временная приостановка, несвоевременная оплата, бан

Различить сценарии: `core_nodes: []` означает, что пользователь ни разу не был одобрен.

---

## Статусы устройств

| Статус | Смысл |
|---|---|
| `inactive` | Запись в реестре есть, в конфигах Entry-нод отсутствует |
| `active` | Присутствует в конфиге хотя бы одной Entry-ноды |
| `archived` | Терминальный: только удаление, никаких операций |

> **Ограничение скриптов:** `devices/modify.sh` поддерживает только `active` и `archived`.
> Статус `inactive` в реестре устройства не задаётся скриптом напрямую.
> «Неактивное» устройство в рамках текущей реализации — это устройство,
> удалённое со всех Entry-нод через `entry/remove-client.sh`, но сохранённое в реестре.

---

## Каскады при смене статуса пользователя

### `active → inactive`

**Каскад:** все устройства снимаются с Entry-нод.

Реализуется в боте последовательностью вызовов скриптов:
1. Для каждого устройства пользователя:
   - Определить Entry-ноды через `core_nodes → routes → entry_ip`
   - `entry/remove-client.sh` для каждой Entry-ноды
2. `users/update.sh --status inactive`

### `inactive → active`

**Каскада нет.** Пользователь получает возможность самостоятельно
активировать свои устройства.

Реализуется вызовом: `users/update.sh --status active`

### `* → archived`

**Каскад:** все устройства снимаются с Entry-нод и архивируются.

Реализуется в боте:
1. Для каждого устройства — `entry/remove-client.sh` на всех Entry-нодах
2. `devices/update.sh --status archived` для каждого устройства
3. `users/update.sh --status archived`

---

## Роли в боте

| Условие | Роль |
|---|---|
| `telegram_id` в `SIGILGATE_ADMIN_IDS` | **ADMIN** |
| `status = active` | **USER** |
| `status = inactive` или `status = archived` или нет записи | **GUEST** |

ADMIN определяется по конфигу, а не по реестру. Администратор может иметь
или не иметь запись в реестре.

---

## Сообщения для GUEST

Разные состояния GUEST требуют разных сообщений:

| Состояние | Как определить | Сообщение |
|---|---|---|
| Нет записи в реестре | `registry_user is None` | Приветствие + предложение `/reg` |
| Ожидает одобрения | `status=inactive` и `core_nodes=[]` | «Ваша заявка рассматривается. Обратитесь к администратору.» |
| Заблокирован | `status=inactive` и `core_nodes` не пустой | «Аккаунт неактивен. Обратитесь к администратору.» |
| Архивирован | `status=archived` | «Аккаунт заблокирован. Обратитесь к администратору.» |

---

## Матрица доступа к операциям

### Пользователь (USER = active)

| Операция | Доступна | Скрипт | Условие |
|---|---|---|---|
| Просмотр своих устройств | да | `devices/list.sh` | — |
| Просмотр карточки устройства | да | `devices/get.sh`, `devices/config.sh` | только своё |
| Добавить устройство | да | `devices/add.sh` | — |
| Переименовать устройство | да | `devices/update.sh --device` | только своё, статус не `archived` |
| Удалить устройство | да | `devices/remove.sh` | только своё |
| Активировать устройство | да | `entry/add-client.sh` | только своё, выбор Entry-ноды |
| Деактивировать устройство | да | `entry/remove-client.sh` | только своё |

### Администратор (ADMIN)

Имеет доступ ко всем операциям USER плюс:

| Операция | Скрипт | Описание |
|---|---|---|
| Просмотр всех пользователей | `users/list.sh` | с фильтрами |
| Просмотр карточки пользователя | `users/get.sh` | — |
| Одобрить заявку | `users/update.sh --status active` + назначить Core-ноду | — |
| Удалить заявку | `users/remove.sh` | если нет устройств |
| Забанить (archived) | `users/update.sh --status archived` | + каскад устройств |
| Приостановить (inactive) | `users/update.sh --status inactive` | + каскад устройств |
| Восстановить (active) | `users/update.sh --status active` | без каскада |
| Удалить пользователя | `users/remove.sh` | + все устройства |

---

## Workflow одобрения регистрации

```
GUEST → /reg → создаётся запись (status=inactive, core_nodes=[])
                     ↓
             бот уведомляет всех ADMIN
                     ↓
         ┌───────────┼────────────┐
         ↓           ↓            ↓
     Одобрить     Удалить       Забанить
    (FSM: выбор  (remove.sh)  (archived)
     Core-ноды)
         ↓
  status=active + core_nodes=[выбранная нода]
```

### Выбор Core-ноды при одобрении

Администратор выбирает из списка активных Core-нод. После выбора бот:
1. Устанавливает `core_nodes` пользователя (через прямое редактирование JSON + коммит,
   либо будущий скрипт `users/modify.sh --core-nodes`)
2. Меняет статус: `users/update.sh --id ... --status active`

---

## Workflow управления устройствами пользователем

### Добавление устройства

```
USER → вводит имя → devices/add.sh → UUID добавляется в Xray на Entry-нодах
                                       через core_nodes → routes → entry_ip
```

### Деактивация устройства (вывод из оборота)

```
USER → выбирает устройство → подтверждает деактивацию
→ entry/remove-client.sh для каждой Entry-ноды пользователя
→ устройство остаётся в реестре (inactive де-факто)
```

### Активация устройства (возврат в оборот)

```
USER → выбирает неактивное устройство → выбирает Entry-ноду(ы)
→ entry/add-client.sh для выбранных Entry-нод
```

> **Текущее состояние:** activate/deactivate как отдельные действия в боте не реализованы.
> Реализовано только добавление (`devices/add.sh`) и полное удаление (`devices/remove.sh`).

### Переименование устройства

```
USER → карточка устройства → «Переименовать» → вводит новое имя
→ devices/update.sh --uuid ... --device "новое имя"
```

> **Текущее состояние:** не реализовано в боте.

---

## Entry-ноды, доступные пользователю

Определяются через реестр:
```
User.core_nodes[] → Routes (где core_ip совпадает и status=active) → Routes.entry_ip
```

Бот должен строить этот список динамически при каждой операции выбора Entry-ноды,
читая `routes/*.json` из `SIGIL_STORE_PATH`.
