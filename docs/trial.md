# Триал-доступ (`/trial`)

Функционал бесплатного пробного подключения к сети без регистрации.

---

## Содержание

1. [Назначение и концепция](#1-назначение-и-концепция)
2. [Пользовательский сценарий](#2-пользовательский-сценарий)
3. [Ключевая идея: имя устройства как состояние](#3-ключевая-идея-имя-устройства-как-состояние)
4. [Технический флоу команды /trial](#4-технический-флоу-команды-trial)
5. [Жизненный цикл триал-устройства](#5-жизненный-цикл-триал-устройства)
6. [Управление сроком действия (lifetime)](#6-управление-сроком-действия-lifetime)
7. [Очистка при одобрении регистрации](#7-очистка-при-одобрении-регистрации)
8. [Справочник скриптов trial/](#8-справочник-скриптов-trial)
9. [Systemd timer на Core-ноде](#9-systemd-timer-на-core-ноде)
10. [Граничные случаи](#10-граничные-случаи)
11. [Константы и параметры](#11-константы-и-параметры)

---

## 1. Назначение и концепция

Команда `/trial` позволяет незарегистрированному пользователю получить
VLESS-ссылку для тестового подключения к сети на **1 час** — без создания
аккаунта и без участия администратора.

**Ключевые ограничения:**
- Ссылка действует ровно 1 час, после чего UUID автоматически отзывается
- Каждый запрос `/trial` — новое независимое подключение (новый UUID)
- Общий лимит использований на одного пользователя: **10 раз**
- По исчерпании лимита пользователь получает приглашение пройти регистрацию

**Доступ:**
- `GUEST` — основная аудитория команды
- `ADMIN` — доступен для тестирования функционала
- `USER` — заблокирован (активный пользователь не нуждается в триале)

**Инфраструктурная основа:**
Все триал-устройства создаются под сервисным пользователем `trial` (ID=3) в реестре.
Этот пользователь имеет статус `active` и привязан к той же Core-ноде, что и обычные пользователи.

---

## 2. Пользовательский сценарий

```
Пользователь → /trial
                │
                ├─ [первое использование]
                │   Бот: «Пробное подключение. Ссылка действует 1 час.
                │          Осталось попыток после этого: 9»
                │   + VLESS-ссылка
                │
                ├─ [повторное использование, лимит не исчерпан]
                │   Бот: «Пробное подключение. Ссылка действует 1 час.
                │          Осталось попыток после этого: 7»
                │   + VLESS-ссылка
                │
                ├─ [последнее использование, digit=0]
                │   Бот: «Это ваше последнее пробное подключение.
                │          Для продолжения пройдите регистрацию: /reg»
                │   + VLESS-ссылка
                │
                └─ [лимит исчерпан]
                    Бот: «Лимит пробных подключений исчерпан.
                          Для получения постоянного доступа: /reg»
```

---

## 3. Ключевая идея: имя устройства как состояние

Состояние лимита не хранится в отдельном хранилище. Оно **кодируется прямо
в имени устройства** в реестре, что исключает необходимость в дополнительных
зависимостях (SQLite, Redis, файлы состояния).

**Формат имени:**

```
<telegram_id><digit>

где digit — однозначное число [0..9]:
  количество оставшихся попыток ПОСЛЕ данного использования
```

**Примеры для telegram_id = 358669266:**

| Имя устройства | Использование | Осталось после |
|----------------|--------------|----------------|
| `3586692669`   | 1-е (первое) | 9              |
| `3586692668`   | 2-е          | 8              |
| `3586692661`   | 9-е          | 1              |
| `3586692660`   | 10-е (последнее) | 0          |

**Как бот определяет текущий лимит:**

1. Получает все устройства пользователя `trial` через `trial/find.sh --telegram-id <id>`
2. Из всех найденных имён берёт последний символ → список цифр
3. `min(digits)` = минимальный остаток = максимальный расход = текущее состояние счётчика
4. Если `min = 0` → лимит исчерпан; иначе `new_digit = min - 1`
5. Если устройств нет → первое использование, `new_digit = 9`

**Поиск устройств:** `trial/find.sh` фильтрует по регулярному выражению
`^{telegram_id}[0-9]$` — имена, начинающиеся с `telegram_id` и заканчивающиеся
ровно одной цифрой.

---

## 4. Технический флоу команды /trial

### Полная схема

```
/trial (telegram_id=T)
│
├─ [role == USER] → ответ «Вы уже зарегистрированы» → СТОП
│
├─ [1] trial/find.sh --telegram-id T
│       → JSON-массив устройств [{uuid, device, status, created}]
│
├─ [2] Ленивая очистка (lazy expire)
│       Для каждого device со status=active:
│         mtime файла устройства > TRIAL_TTL (3600 сек)?
│         да → asyncio.create_task(trial/expire.sh --uuid <uuid>)
│              (фоновая задача, не блокирует ответ пользователю)
│
├─ [3] Определение нового digit
│       digits = [int(d.device[-1]) for d in all_devices]
│       если digits пустой → new_digit = 9   (первое использование)
│       иначе min_digit = min(digits)
│         если min_digit == 0 → ЛИМИТ ИСЧЕРПАН → ответ + /reg → СТОП
│         иначе new_digit = min_digit - 1
│
├─ [4] devices/add.sh --user 3 --device "<T><new_digit>"
│       Внутри add.sh:
│         devices/create.sh → UUID генерируется, запись создаётся active
│         store/commit.sh   → коммит в реестр
│         nodes/list-entry.sh --user 3 → список Entry-нод пользователя trial
│         entry/add-client.sh --host <Entry-IP> --uuid <UUID>
│                              --service-name <gRPC-path> --name <device_name>
│                             → UUID добавлен в Xray, подключение готово
│       → возвращает UUID в stdout (извлекается regex)
│
├─ [5] devices/config.sh --uuid <UUID>
│       → JSON-массив VLESS-ссылок
│
└─ [6] Ответ пользователю:
        «Пробное подключение. Ссылка действует 1 час.
         Осталось попыток: <new_digit>»
        + <code>vless://UUID@domain:443?...</code>
```

### Вызываемые скрипты (в порядке выполнения)

| Шаг | Скрипт | Тип | Цель |
|-----|--------|-----|------|
| 1 | `trial/find.sh --telegram-id T` | утилита | Получить все устройства |
| 2 (фон) | `trial/expire.sh --uuid` | оркестратор | Очистить просроченные |
| 4 | `devices/add.sh --user 3 --device` | оркестратор | Создать + активировать |
| 5 | `devices/config.sh --uuid` | атомарный | VLESS-ссылка |

---

## 5. Жизненный цикл триал-устройства

```
                    devices/add.sh
                         │
                         ▼
                    ┌─────────┐
                    │  active │  ← UUID присутствует в Xray на Entry-ноде
                    │         │    пользователь подключён
                    └────┬────┘
                         │
              1 час (TRIAL_TTL = 3600 сек)
                         │
           ┌─────────────┴─────────────┐
           │                           │
    cleanup.sh                  lazy expire (бот)
    (systemd timer,          (следующий /trial от
      каждый час)              этого пользователя)
           │                           │
           └─────────────┬─────────────┘
                         │
                  trial/expire.sh
                  ┌──────┴──────┐
                  │ deactivate  │  devices/deactivate.sh
                  │  inactive   │  → снят с Entry-ноды, status=inactive
                  └──────┬──────┘
                         │
                  devices/update.sh --status archived
                         │
                         ▼
                    ┌──────────┐
                    │ archived │  ← UUID удалён из Xray
                    │          │    запись хранится для учёта лимита
                    └────┬─────┘
                         │
                  trial/prune.sh
                  (при наличии более
                   новых архивных записей)
                         │
                         ▼
                    ┌──────────┐
                    │  удалено │  ← только min-digit запись остаётся
                    └──────────┘
```

### Статусы устройства

| Статус | Xray | Реестр | Значение |
|--------|------|--------|----------|
| `active` | присутствует | есть | Подключение активно |
| `inactive` | отсутствует | есть | Срок истёк, ожидает архивирования |
| `archived` | отсутствует | есть | Архив для учёта лимита |
| — | отсутствует | нет | Удалено (prune) |

---

## 6. Управление сроком действия (lifetime)

Проблема: нет надёжного единого таймера. Бот может перезапуститься,
Core-нода — перезагрузиться. Решение: **два независимых механизма**.

### Механизм 1 — Ленивая проверка в боте (`bot/handlers/trial.py`)

Срабатывает каждый раз, когда **тот же пользователь** снова вызывает `/trial`.

```python
for dev in devices:
    if dev["status"] == "active":
        mtime = Path(store_path) / "devices" / f"{dev['uuid']}.json"
        if (now - mtime.stat().st_mtime) >= TRIAL_TTL:
            asyncio.create_task(
                run_script(["trial/expire.sh", "--uuid", dev["uuid"]])
            )
```

**Особенности:**
- Запускается как `asyncio.create_task` — не блокирует ответ пользователю
- Очищает только устройства данного `telegram_id`
- Не гарантирует точность 1 час — но очищает перед следующим использованием

**Почему mtime, а не поле `created`:**
Поле `created` в записи устройства хранит дату в формате `YYYY-MM-DD` (без времени).
Этого недостаточно для определения часового интервала. Время создания файла (`mtime`)
точно соответствует моменту создания устройства, поскольку файл не модифицируется
до момента деактивации (когда `mtime` уже неважен — устройство становится `inactive`).

### Механизм 2 — Systemd timer на Core-ноде (`trial/cleanup.sh`)

Запускается раз в час независимо от активности пользователей.

```
sigilgate-trial-cleanup.timer
    OnBootSec=5min
    OnUnitActiveSec=1h
         │
         ▼
sigilgate-trial-cleanup.service
    ExecStart=/home/sigil/SigilGate/scripts/trial/cleanup.sh
         │
         ├─ [1] Для каждого active-устройства пользователя trial:
         │       stat -c %Y <device-file> → возраст файла
         │       если возраст ≥ 3600 сек → trial/expire.sh --uuid
         │
         └─ [2] Для каждого уникального telegram_id среди archived-устройств:
                 trial/prune.sh --telegram-id
```

**Гарантия:** даже если пользователь никогда не вернётся в бот,
UUID будет отозван из Xray не позднее чем через ~2 часа (час жизни + до часа ожидания таймера).

### Сравнение механизмов

| | Ленивая проверка | Systemd timer |
|--|--|--|
| Срабатывает | При следующем `/trial` от пользователя | Каждый час |
| Охват | Только текущий telegram_id | Все триал-устройства |
| Точность | Приблизительная | Приблизительная (±1 час) |
| Зависимость от бота | Да | Нет |
| Устойчивость к перезапуску | Да | Да |

---

## 7. Очистка при одобрении регистрации

При одобрении заявки пользователя (в обоих сценариях: через уведомление о
новой заявке и через карточку пользователя) бот автоматически удаляет все
его триал-устройства.

**Где реализовано:** `bot/handlers/admin.py` → функция `_cleanup_trial_devices()`

**Вызывается из:**
- `cb_reg_core` — одобрение через уведомление о регистрации
- `cb_user_core` — одобрение через карточку пользователя в `/users`

**Схема:**

```
Администратор одобряет заявку
         │
         ├─ users/update.sh --id <id> --add-core-node <ip> --status active
         │
         ├─ bot.send_message → пользователю: «Заявка одобрена»
         │
         └─ _cleanup_trial_devices(telegram_id)
                  │
                  ├─ trial/find.sh --telegram-id <tg_id>
                  │   → все устройства (active + inactive + archived)
                  │
                  └─ для каждого:
                      devices/remove.sh --uuid <uuid>
                      → снят с Entry-ноды (если active) + удалён из реестра
```

**Логика:** зарегистрированному пользователю триал-устройства больше не нужны.
Их удаление освобождает Xray от ненужных клиентов и очищает реестр.

---

## 8. Справочник скриптов trial/

Все скрипты находятся в `scripts/trial/`. Используют общую библиотеку `lib/common.sh`.
Дополнительная переменная окружения: `SIGIL_TRIAL_USER_ID` (по умолчанию `3`).

---

### `trial/find.sh` [утилита]

Поиск триал-устройств по `telegram_id`.

```bash
trial/find.sh --telegram-id <id> [--status active|inactive|archived]
```

| Параметр | Обязательный | Описание |
|---|---|---|
| `--telegram-id` | да | Telegram ID пользователя |
| `--status` | нет | Фильтр по статусу |

**Возвращает:** JSON-массив `[{uuid, device, status, created}]` в `stdout`.
Пустой массив `[]` если ничего не найдено.

**Принцип:** перебирает все файлы `devices/*.json` пользователя trial,
отбирает те, чьё имя соответствует `^{telegram_id}[0-9]$`.

```json
[
  {
    "uuid": "550e8400-e29b-41d4-a716-446655440000",
    "device": "3586692669",
    "status": "archived",
    "created": "2026-02-21"
  },
  {
    "uuid": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    "device": "3586692668",
    "status": "active",
    "created": "2026-02-21"
  }
]
```

---

### `trial/expire.sh` [оркестратор]

Истечение срока одного триал-устройства.

```bash
trial/expire.sh --uuid <uuid>
```

| Параметр | Обязательный |
|---|---|
| `--uuid` | да |

**Последовательность:**

```
expire.sh
    │
    ├─ [если status=active]
    │   devices/deactivate.sh --uuid
    │       → entry/remove-client.sh (SSH на Entry-ноду)
    │       → devices/modify.sh --status inactive
    │       → store/commit.sh
    │
    └─ devices/update.sh --uuid --status archived
           → devices/modify.sh --status archived
           → store/commit.sh
```

**Идемпотентен:** если устройство уже `archived` — `exit 0`.

---

### `trial/prune.sh` [оркестратор]

Прореживание архивных записей: оставляет только запись с наименьшей цифрой
лимита (минимальный остаток = максимальное число использований = актуальный счётчик).

```bash
trial/prune.sh --telegram-id <id>
```

| Параметр | Обязательный |
|---|---|
| `--telegram-id` | да |

**Алгоритм:**

```
archived_devices = find.sh --telegram-id T --status archived
если len <= 1 → выход (нечего прореживать)

min_digit = min(int(d.device[-1]) for d in archived_devices)

для каждого устройства:
    если digit == min_digit и ещё не сохранили одно → пропустить (сохранить)
    иначе → devices/remove.sh --uuid   (удалить из реестра и Entry-нод)
```

**Пример:**

```
Устройства: 3586692669 (archived), 3586692668 (archived), 3586692667 (archived)
min_digit = 7
Сохраняется: 3586692667
Удаляются:   3586692668, 3586692669
```

---

### `trial/cleanup.sh` [оркестратор]

Плановая очистка всех триал-устройств. Запускается по systemd timer.

```bash
trial/cleanup.sh [--max-age <секунды>]   # по умолчанию 3600
```

| Параметр | Обязательный | Описание |
|---|---|---|
| `--max-age` | нет | Порог возраста файла в секундах (по умолчанию 3600) |

**Последовательность:**

```
cleanup.sh
    │
    ├─ [1] Истечение активных устройств
    │       для каждого active-устройства пользователя trial:
    │           возраст = now - stat(mtime файла)
    │           если возраст >= max-age:
    │               trial/expire.sh --uuid
    │
    └─ [2] Прореживание архивных записей
            собрать уникальные telegram_id из archived-устройств
            для каждого:
                trial/prune.sh --telegram-id
```

---

## 9. Systemd timer на Core-ноде

Два юнита размещены на Core-ноде (`202.223.48.9`).

### `/etc/systemd/system/sigilgate-trial-cleanup.service`

```ini
[Unit]
Description=Sigil Gate — trial cleanup

[Service]
Type=oneshot
User=sigil
EnvironmentFile=/home/sigil/.config/sigilgate-bot.env
ExecStart=/home/sigil/SigilGate/scripts/trial/cleanup.sh
```

### `/etc/systemd/system/sigilgate-trial-cleanup.timer`

```ini
[Unit]
Description=Sigil Gate — trial cleanup (hourly)

[Timer]
OnBootSec=5min
OnUnitActiveSec=1h

[Install]
WantedBy=timers.target
```

### Управление

```bash
# Статус таймера
systemctl status sigilgate-trial-cleanup.timer

# Запустить очистку вручную (для диагностики)
systemctl start sigilgate-trial-cleanup.service

# Просмотр логов очистки
journalctl -u sigilgate-trial-cleanup.service -n 50

# Ближайшее плановое срабатывание
systemctl list-timers sigilgate-trial-cleanup.timer
```

### Зависимости на Core-ноде

Переменные окружения сервиса (`EnvironmentFile`):

| Переменная | Значение |
|---|---|
| `SIGIL_STORE_PATH` | `/home/sigil/SigilGate/registry` |
| `SIGIL_SSH_KEY` | `/home/sigil/.ssh/id_rsa` |
| `SIGIL_SSH_USER` | `sigil` |
| `SIGIL_SSH_PASSWORD` | `<sudo password>` |
| `SIGIL_TRIAL_USER_ID` | `3` (опционально, по умолчанию 3) |

---

## 10. Граничные случаи

### Пользователь запрашивает /trial несколько раз подряд

Каждый вызов `/trial` создаёт **новое устройство** и уменьшает лимит.
Параллельные активные устройства допустимы: пользователь может держать
несколько одновременных подключений за счёт своего лимита.

### Бот перезапустился во время активной сессии

UUID остаётся в Xray. При следующем вызове `/trial` ленивая проверка
найдёт просроченное устройство (по mtime) и запустит `expire.sh` в фоне.
Если пользователь больше не пишет — `cleanup.sh` отзовёт UUID не позднее
чем через час.

### Core-нода перезагрузилась

Таймер `sigilgate-trial-cleanup.timer` имеет `OnBootSec=5min` — запустится
через 5 минут после загрузки и очистит все просроченные устройства.

### Пользователь зарегистрировался, не исчерпав лимит

При одобрении регистрации `_cleanup_trial_devices()` удаляет все его
триал-устройства через `devices/remove.sh`. Активные UUID отзываются
с Entry-ноды. Данные о лимите стираются (они больше не нужны).

### devices/add.sh завершился ошибкой SSH

Если Entry-нода недоступна, `add.sh` вернёт ненулевой exit code.
Бот покажет «Не удалось создать пробное подключение. Попробуйте позже.»
Запись в реестре при этом может быть уже создана (коммит произошёл до
применения на Entry-ноде). Очередной запуск `cleanup.sh` найдёт `active`-устройство
без реального UUID в Xray и попытается его деактивировать (idempotent — `exit 0`).

### Пользователь пытается угадать digit или подделать имя устройства

`trial/find.sh` ищет имена, точно соответствующие маске `^{telegram_id}[0-9]$`.
Telegram ID жёстко привязан к идентификатору Telegram-аккаунта и недоступен
для подмены через бота.

---

## 11. Константы и параметры

Все константы определены в `bot/handlers/trial.py`:

| Константа | Значение | Описание |
|---|---|---|
| `TRIAL_USER_ID` | `"3"` | ID сервисного пользователя в реестре |
| `TRIAL_LIMIT_START` | `9` | digit при первом использовании (всего 10 попыток: 9..0) |
| `TRIAL_TTL` | `3600` | Время жизни подключения, секунды |

Для изменения лимита (например, с 10 до 3 попыток) достаточно изменить
`TRIAL_LIMIT_START = 2` (первое устройство получит digit=2, итого 3 использования: 2, 1, 0).
